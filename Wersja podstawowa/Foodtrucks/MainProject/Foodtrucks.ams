## ams_version=1.0

Model Main_Foodtrucks {
	MathematicalProgram HighestCostPlan {
		Objective: TotalCost;
		Direction: maximize;
		Constraints: AllConstraints;
		Variables: AllVariables;
		Text: "funkcja celu - maksymalizacja zysków ze sprzedaży posiłków";
		Type: Automatic;
	}
	Parameter MaxVisited {
		Text: "Maksymaln";
		Definition: 4;
	}
	Parameter PlaceTime {
		Text: "Czas spędzany w jednym punkcie [h]";
		Definition: 2;
	}
	Parameter Vehicles {
		Definition: 1;
	}
	Parameter FuelPrice {
		Text: "cena benzyny [zł/l]";
		Definition: 6;
	}
	Parameter MealPrice {
		Text: "cena posiłku [zł]";
		Definition: 15;
	}
	Set Places {
		Text: "Możliwe punkty postoju foodtrucka";
		Index: i, j;
		Definition: data { A,B,C,D,E,F,G,H,I };
	}
	Parameter Distances {
		IndexDomain: (i,j);
		Text: "Odległości między punktem i a punktem j";
		Definition: {
			data 
			{ ( A, B ) : 2.700,  ( A, C ) : 6.800,  ( A, D ) : 4.200,  ( A, E ) : 1.100,  ( A, F ) : 1.400,  ( A, G ) : 2.200,
			  ( A, H ) : 4.300,  ( A, I ) : 4.900,  ( B, A ) : 2.700,  ( B, C ) : 5.300,  ( B, D ) : 2.200,  ( B, E ) : 1.800,
			  ( B, F ) : 2.700,  ( B, G ) : 1.700,  ( B, H ) : 3.400,  ( B, I ) : 4.200,  ( C, A ) : 6.800,  ( C, B ) : 5.300,
			  ( C, D ) : 3.700,  ( C, E ) : 6.500,  ( C, F ) : 7.000,  ( C, G ) : 6.800,  ( C, H ) : 8.600,  ( C, I ) : 9.300,
			  ( D, A ) : 4.200,  ( D, B ) : 2.200,  ( D, C ) : 3.700,  ( D, E ) : 3.300,  ( D, F ) : 3.900,  ( D, G ) : 3.600,
			  ( D, H ) : 4.500,  ( D, I ) : 4.200,  ( E, A ) : 1.100,  ( E, B ) : 1.800,  ( E, C ) : 6.500,  ( E, D ) : 3.300,
			  ( E, F ) : 2.600,  ( E, G ) : 1.600,  ( E, H ) : 3.100,  ( E, I ) : 4.100,  ( F, A ) : 1.400,  ( F, B ) : 2.700,
			  ( F, C ) : 7.000,  ( F, D ) : 3.900,  ( F, E ) : 2.600,  ( F, G ) : 2.900,  ( F, H ) : 5.200,  ( F, I ) : 5.300,
			  ( G, A ) : 2.200,  ( G, B ) : 1.700,  ( G, C ) : 6.800,  ( G, D ) : 3.600,  ( G, E ) : 1.600,  ( G, F ) : 2.900,
			  ( G, H ) : 2.600,  ( G, I ) : 3.700,  ( H, A ) : 4.300,  ( H, B ) : 3.400,  ( H, C ) : 8.600,  ( H, D ) : 4.500,
			  ( H, E ) : 3.100,  ( H, F ) : 5.200,  ( H, G ) : 2.600,  ( H, I ) : 2.000,  ( I, A ) : 4.900,  ( I, B ) : 4.200,
			  ( I, C ) : 9.300,  ( I, D ) : 4.200,  ( I, E ) : 4.100,  ( I, F ) : 5.300,  ( I, G ) : 3.700,  ( I, H ) : 2.000 }
		}
	}
	Parameter Combustion {
		Text: "spalanie foodtrucka w l/h";
		Definition: 12;
	}
	Parameter Incidences {
		IndexDomain: (i,j);
		Text: "macierz incydencji";
		Definition: {
			data 
			{ ( A, B ) : 1,  ( A, E ) : 1,  ( A, F ) : 1,  ( A, G ) : 1,  ( B, A ) : 1,  ( B, C ) : 1,  ( B, D ) : 1,  ( B, E ) : 1,
			  ( B, F ) : 1,  ( B, G ) : 1,  ( C, A ) : 1,  ( C, B ) : 1,  ( C, D ) : 1,  ( D, A ) : 1,  ( D, B ) : 1,  ( D, C ) : 1,
			  ( D, E ) : 1,  ( E, A ) : 1,  ( E, B ) : 1,  ( E, D ) : 1,  ( E, F ) : 1,  ( E, G ) : 1,  ( E, H ) : 1,  ( E, I ) : 1,
			  ( F, A ) : 1,  ( F, B ) : 1,  ( F, E ) : 1,  ( F, G ) : 1,  ( G, A ) : 1,  ( G, B ) : 1,  ( G, E ) : 1,  ( G, F ) : 1,
			  ( G, H ) : 1,  ( G, I ) : 1,  ( H, E ) : 1,  ( H, G ) : 1,  ( H, I ) : 1,  ( I, E ) : 1,  ( I, G ) : 1,  ( I, H ) : 1 }
		}
	}
	Parameter Profits {
		IndexDomain: i;
		Text: "zapotrzebowanie na ilość posiłków w i-tym punkcie [ilość/h]";
		Definition: data { A : 487,  B : 937,  C : 813,  D : 565,  E : 308,  F : 758,  G : 512,  H : 769,  I : 806 };
	}
	Variable StartingPlaces {
		IndexDomain: j;
		Text: "wartość określająca, od jakich punktów należy zacząć trasę foodtrucka";
		Range: binary;
	}
	Variable Routes {
		IndexDomain: (i,j);
		Text: "informacja, czy przejechano z punktu i do punktu j";
		Range: binary;
	}
	Variable TotalCost {
		Text: "wartość funkcji celu";
		Range: free;
		Definition: sum[i, MealPrice * Profits(i) * 2 * sum[j, Routes(i,j)]] - sum[(i,j), Routes(i,j) * Distances(i,j) * FuelPrice * Combustion];
	}
	Constraint FuelConstraint {
		Text: "Ograniczenie dotyczące benzyny - ilość zużytej benzyny nie może być większa niż pojemność baku";
		Definition: 0 <= sum[(i,j), Routes(i,j) * Distances(i,j) * Combustion] <= 100 * Vehicles;
	}
	Constraint MealConstraint {
		Text: "Ograniczenie dotyczące pojemności foodtrucka - ilość sprzedanych danego dnia posiłków musi być mniejsze bądź równe od ilości posiłków, które może zagwarantować foodtruck";
		Definition: 0 <= sum[i, Profits(i) * PlaceTime * sum[j, Routes(i,j)]] <= 5000*Vehicles;
	}
	Constraint StartingPointsConstraint {
		Text: "Ograniczenie na liczbę pojazdów i punktów, od których rozpoczynana jest trasa foodtrucka - punktów startowych nie może być więcej niż pojazdów";
		Definition: sum[j, StartingPlaces(j)] <= Vehicles;
		Comment: "sum[j, StartingPlaces(j)] <= Vehicles";
	}
	Constraint IncidencesContraint {
		IndexDomain: (i,j);
		Text: "Ograniczenie dotyczące informacji możliwego przemieszczenia między punktem i, a punktem j - maksymalnie możliwa wartość jest określona w macierzy incydencji Mij";
		Definition: 0 <= Routes(i,j) <= Incidences(i,j);
	}
	Constraint VehicleConstraint {
		IndexDomain: i;
		Text: "Ograniczenia na wykorzystanie liczby foodtracków względem możliwych do odwiedzenia punktów";
		Definition: sum[j, Routes(i,j)] <= Vehicles * (MaxVisited - 1);
	}
	Constraint VisitConstraint {
		IndexDomain: j;
		Text: "Ograniczenie na maksymalnie możliwe przemieszczenie się z punktu i do punktu j - w ciągu dnia jeden punkt może być wybrany maksymalnie jeden raz";
		Definition: 0 <= sum[i, Routes[i,j]] + StartingPlaces(j) <= 1;
	}
	Procedure MainInitialization {
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainExecution {
		Body: {
			solve HighestCostPlan;
		}
	}
	Procedure PreMainTermination {
		Body: {
			return DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
	Section Quantities_and_Units {
		Comment: {
			"This section contains all the units and quantities that are added automatically by AIMMS.
			It is recommended to declare all your quantities here."
		}
		Quantity SI_Time_Duration {
			BaseUnit: s;
			Conversions: minute->s : #-># * 60;
			Comment: {
				"Expresses the value for the duration of periods.
				
				The unit s has been added automatically because it is a required unit for AimmsWebUI.
				
				The unit minute has been added automatically because it is a required unit for AimmsWebUI."
			}
		}
	}
}
